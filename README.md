# Sorting-Visualiser

A Python program that uses Pygame to visualize different sorting algorithms.

## Requirements
- Python 3
- Pygame

## Supported Algorithms
- Bubble sort
- Insertion sort
- Merge sort
- Quick sort

## Screenshots

![Unsorted Data Set](https://github.com/ChristianGleitzman/Sorting-Visualiser/blob/main/Unsorted.PNG)
![Sorted Data Set](https://github.com/ChristianGleitzman/Sorting-Visualiser/blob/main/sorted.PNG)

## Skills

- Algorithm design and analysis: Sorting algorithms are a fundamental part of computer science, this required a good understanding of how different sorting algorithms work and their relative performance characteristics.
- Event-driven programming: Pygame is an event-driven library, this required a good understanding of how to handle user input and other events.
- 2D graphics programming: Pygame is a powerful tool for creating 2D graphics, this project required a good understanding of how to create and manipulate pygame shapes
- Debugging and troubleshooting: As with any programming project, this project required debugging and troubleshooting skills to identify and fix any bugs or issues that arose.

## Possible Improvements

- Adding the ability to input custom data sets for sorting, instead of using a random data set.
- Providing more detailed information about the sorting process, such as the number of comparisons and swaps made.
- Adding a step-by-step mode that allows users to see the algorithm's progress one step at a time.
- Adding a feature that allows users to compare the performance of different sorting algorithms on the same data set.
- Adding the ability to pause, rewind, and fast-forward the animation to study the sorting process in more detail.
- Adding the ability to select the size of the data set to sort, so that the user can see how the performance of the algorithm changes as the data set grows.

## Note
The sorting algorithm visualizer is for educational purposes only. It is not recommended for use in production environments as the algorithms used may not be the most efficient for large data sets.
